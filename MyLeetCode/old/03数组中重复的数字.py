# -*-coding:UTF-8-*-
"""
本题方法很多，每个方法都有优点和缺点，题目也没有限制是否可以使用额外空间，是否可以修改原始数组。如果在面试的时候，需要询问面试官是否有这些限制，并给出对应的解决方案。

在实际的工作中，我们遇到的问题很多时候也不会直接告诉我们有哪些限制，需要我们根据实际情况，具体分析应该使用哪种方法。所以有些面试官可能出的一些题目就是没有说的很清楚，他希望你向他提问，就是为了考察你是不是有考虑得很全面（面试就酱紫，是和活生生的人对话，不是做题 Accept 就完事，大家要稳，习惯就好，有的时候不能 Accept ，但是面试官看到了你其他方面的素质，其实也会给通过的）。

所以这道题是一个“很有话说”的问题，面试的时候遇到的话，可以和面试官展开讨论（扯的有点远了，大家体会意思就好。）

方法一：哈希表（最自然，但是要额外空间）
最容易想到用哈希表判重，这种方法是最自然的。

特别地，在数组的长度不超过 3232 的时候，使用位运算的技巧可以实现 O(1)O(1) 空间复杂度判重，但是这道题不是回溯算法的问题，题目给出的测试用例的长度肯定不止 32 位，因此，不建议使用位运算的技巧。

分析：这种方法不修改原始数组，但是使用了 O(N)O(N) 空间，使用空间换时间，是最正常的思路，时间复杂度是 O(N)O(N)。

方法二：排序（也比较容易想到，但是要排序，复杂度高）
排序以后，再遍历一遍就知道哪个重复了。

分析：这个方法其实比较容易想到，但是时间复杂度是 O(N \log N)O(NlogN)，同时也修改了原始数组。

方法三：把数组视为哈希表（有一类问题是这么做的，但是会修改数组）
由于数组元素的值都在指定的范围内，这个范围恰恰好与数组的下标可以一一对应；
因此看到数值，就可以知道它应该放在什么位置，这里数字nums[i] 应该放在下标为 i 的位置上，这就像是我们人为编写了哈希函数，这个哈希函数的规则还特别简单；
而找到重复的数就是发生了哈希冲突；
类似问题还有「力扣」第 41 题： 缺失的第一个正数、「力扣」第 442 题： 数组中重复的数据、「力扣」第 448 题： 找到所有数组中消失的数字 。
分析：这个思路利用到了数组的元素值的范围恰好和数组的长度是一样的，因此数组本身可以当做哈希表来用。遍历一遍就可以找到重复值，但是修改了原始数组。



方法四：二分法（为了不修改数组，要遍历数组很多遍）
由于要确定的数字是有范围的整数，因此可以使用二分法来确定这个数，这就是「力扣」第 278 题：“寻找重复数”，题目有一点点不一样，但思想是一样。

分析：这种做法，不修改原始数组，不使用额外空间（即不像使用哈希表的方法那样，使用 O(N)O(N) 空间），但是看了数组很多遍，是很反常的“使用时间换空间”的做法。

「力扣」第 278 题：“寻找重复数”，还有一种做法是快慢指针，就更难想到了，这里只是做提示，大家可以在这道题的题解区和评论去看到这种解法，这里就不展开了。


"""


def findRepeatNumber(nums):
    assert isinstance(nums, (list, tuple))
    dd = {}
    count = 1
    for i, num in enumerate(nums):
        if num in dd:
            count += 1
        else:
            dd[num] = i
        if count > 1:
            return num
    return "没有重复的数"


if __name__ == '__main__':
    # input_data = eval(input("请输入一个数组，长度在2-10000之间，例如：[2,3,4]\n"))
    input_data = [2, 3, 4, 4]

    result = findRepeatNumber(input_data)

    print("结果为：", result)
